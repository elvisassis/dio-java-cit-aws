package br.com.elvis.assis.dao;import br.com.elvisassis.generics.dao.GenericDAO;import br.com.elvisassis.generics.domain.UserDomain;import br.com.elvisassis.generics.repository.Repository;import org.junit.jupiter.api.BeforeEach;import org.junit.jupiter.api.DisplayName;import org.junit.jupiter.api.Test;import org.junit.jupiter.params.ParameterizedTest;import org.junit.jupiter.params.provider.MethodSource;import org.junit.jupiter.params.provider.ValueSource;import java.util.ArrayList;import java.util.List;import java.util.Optional;import java.util.stream.Stream;import static org.junit.jupiter.api.Assertions.*;@DisplayName("GenericDAO — Advanced Java Generics Tests")public class GenericDAOTest {    private TestUserDAO dao;    @BeforeEach    void setup() {        dao = new TestUserDAO();    }    @Test    @DisplayName("save(T) → Consumes and produces the same generic type")    void shouldSaveAndReturnSameType() {        UserDomain user = new UserDomain(1, "Alice", 20);        UserDomain saved = dao.save(user);        assertEquals(user, saved);        assertEquals(1, dao.count());    }    @Test    @DisplayName("saveBatch(T...) → Saves multiple elements keeping type safety")    void shouldSaveBatchUsingVarargs() {        UserDomain u1 = new UserDomain(1, "Alice", 20);        UserDomain u2 = new UserDomain(2, "Bob", 20);        boolean result = dao.saveBatch(2, u1, u2);        assertTrue(result);        assertEquals(2, dao.count());    }    @Test    @DisplayName("saveAll(Collection<? extends T>) → Reads from a producer collection (covariance)")    void shouldAcceptSubclassCollectionUsingExtends() {        List<UserDomain> users = List.of(                new UserDomain(1, "Alice", 20),                new UserDomain(2, "Bob", 30)        );        dao.saveAll(users); // ? extends T        assertEquals(2, dao.count());    }    @Test    @DisplayName("findAll() → Returns an immutable snapshot of internal storage")    void findAllShouldReturnImmutableList() {        dao.save(new UserDomain(1, "Alice", 20));        List<UserDomain> result = dao.findAll();        assertThrows(UnsupportedOperationException.class,                () -> result.add(new UserDomain(2, "Bob", 30)));    }    @Test    @DisplayName("find(Predicate<T>) → Finds elements using a generic predicate")    void shouldFindByPredicate() {        UserDomain alice = new UserDomain(1, "Alice", 30);        dao.save(alice);        Optional<UserDomain> found = dao.find(u -> u.getId().equals(1));        assertTrue(found.isPresent());        assertEquals("Alice", found.get().toString().contains("Alice") ? "Alice" : "");    }    @Test    @DisplayName("Generic method → Accepts any GenericDomain regardless of ID type")    void genericMethodShouldAcceptAnyGenericDomain() {        List<UserDomain> users = List.of(                new UserDomain(1, "Alice", 20),                new UserDomain(2, "Bob", 30)        );        assertDoesNotThrow(() ->                Repository.printIds(users)        );    }    @Test    @DisplayName("update(ID, T) → Replaces entity while preserving generic constraints")    void shouldUpdateEntityById() {        UserDomain original = new UserDomain(1, "Alice", 20);        dao.save(original);        UserDomain updated = new UserDomain(1, "Alice Updated", 21);        dao.update(1, updated);        UserDomain result = dao.find(u -> u.getId().equals(1)).orElseThrow();        assertTrue(result.toString().contains("Updated"));    }    @Test    void shouldDeleteEntity() {        UserDomain user = new UserDomain(1, "Alice", 20);        dao.save(user);        boolean removed = dao.delete(user);        assertTrue(removed);        assertEquals(0, dao.count());    }    @Test    @DisplayName("addIntegers(List<? super Integer>) → Consumes Integers using contravariance")    void shouldAddIntegersToSuperTypeList() {        List<Number> numbers = new ArrayList<>();        List<? super Integer> result = Repository.addIntegers(numbers);        assertEquals(3, numbers.size());        assertTrue(numbers.contains(1));        assertTrue(numbers.contains(2));        assertTrue(numbers.contains(3));    }    @Test    void countShouldReflectInternalState() {        dao.save(new UserDomain(1, "Alice", 20));        dao.save(new UserDomain(2, "Bob", 30));        assertEquals(2, dao.count());    }    @ParameterizedTest(name = "saveAll should accept collection with {0} elements")    @ValueSource(ints = {1, 3, 5})    @DisplayName("saveAll(Collection<? extends T>) → Accepts producer collections of varying sizes")    void shouldSaveAllUsingCovariantCollection(int size) {        List<UserDomain> users = new ArrayList<>();        for (int i = 1; i <= size; i++) {            users.add(new UserDomain(i, "User " + i, 20+i));        }        dao.saveAll(users);        assertEquals(size, dao.count());    }    @ParameterizedTest(name = "find should locate user with id = {0}")    @ValueSource(ints = {1, 2, 3})    @DisplayName("find(Predicate<T>) → Works with different predicates without breaking generics")    void shouldFindUsingDifferentPredicates(int id) {        dao.save(new UserDomain(1, "Alice", 20));        dao.save(new UserDomain(2, "Bob", 21));        dao.save(new UserDomain(3, "Charlie", 22));        Optional<UserDomain> result = dao.find(u -> u.getId().equals(id));        assertTrue(result.isPresent());        assertEquals(id, result.get().getId());    }    @ParameterizedTest(name = "update should replace entity with id {0}")    @ValueSource(ints = {10, 20, 30})    @DisplayName("update(ID, T) → Preserves generic ID consistency across updates")    void shouldUpdateEntityUsingGenericId(int id) {        dao.save(new UserDomain(id, "Original", 20));        UserDomain updated = new UserDomain(id, "Updated", 20);        dao.update(id, updated);        UserDomain result = dao.find(u -> u.getId().equals(id)).orElseThrow();        assertTrue(result.toString().contains("Updated"));    }    @ParameterizedTest(name = "addIntegers should work with {0}")    @MethodSource("superTypeLists")    @DisplayName("addIntegers(List<? super Integer>) → Accepts multiple supertype lists")    void shouldAddIntegersToAnySuperTypeList(List<? super Integer> list) {        Repository.addIntegers(list);        assertEquals(3, list.size());    }    static Stream<List<? super Integer>> superTypeLists() {        return Stream.of(                new ArrayList<Integer>(),                new ArrayList<Number>(),                new ArrayList<Object>()        );    }    @ParameterizedTest(name = "printIds should accept list of size {0}")    @ValueSource(ints = {1, 2, 4})    @DisplayName("Static generic method → Works with any GenericDomain implementation")    void staticGenericMethodShouldWorkForAnyDomain(int size) {        List<UserDomain> users = new ArrayList<>();        for (int i = 1; i <= size; i++) {            users.add(new UserDomain( i, "User " + i, 20));        }        assertDoesNotThrow(() ->               Repository.printIds(users)        );    }}